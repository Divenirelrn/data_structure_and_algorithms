/*
字符串：
	刚开始的计算机都是处理数值工作，后来引入了字符串的概念。
	计算机开始可以处理非数值的概念了。
	（当然原理还是用数值来模拟非数值，通过ASCII码表）

	 串（String）是由零个或多个字符组成的有限序列，又名叫字符串。

	 字符串的比较：
		比的就是字符串里每个字符的ASCII码大小，
		因为：‘F’== 70 ‘f’== 102，‘f’>‘F’
		所以：“fishc.com”>“FishC”

	字符串的存储结构
		字符串的存储结构与线性表相同，也分顺序存储结构和链式存储结构。
		字符串的顺序存储结构是用一组地址连续的存储单元来存储串中的字符序列的。
		按照预定义的大小，为每个定义的字符串变量分配一个固定长度的存储区，一般用定长数组来定义。

		与线性表相似处：
			既然是固定长度的存储区，就存在一个空间分配不灵活的问题，那么会考虑用链式存储结构。

		与线性表不同处：
			字符串我们一般都是连在一起表述的，“断章取义”的情况并不多，所以习惯上我们通常还是会直接定义一个足够长度的存储区来存储的。

	BF算法( Brute Force)：
		BF算法属于朴素的模式匹配算法，它的核心思想是：
        有两个字符串S和T，长度为N和M。首先S[1]和T[1]比较，若相等，则再比较S[2]和T[2]，一直到T[M]为止；
		若S[1]和T[1]不等，则T向右移动一个字符的位置，再依次进行比较。
        该算法最坏情况下要进行M*(N-M+1)次比较，时间复杂度为O(M*N)。
		在这里S是主串，T是子串，这种子串的定位操作通常称作串的模式匹配。

	KMP算法：
		KMP算法是三位老前辈（D.E.Knuth、J.H.Morris 和 V.R.Pratt）的研究结果，大大的避免重复遍历的情况。
		全称叫做克努特-莫里斯-普拉特算法，简称KMP算法或看毛片算法。
		上节课我们谈了BF算法，也说了BF算法虽然很黄很暴力，但是效率却不高。

		回溯的核心：
		坚持条条大路通罗马的决心，然后遇到挫折就回到跌倒的地方重新爬起来，继续往前。。。
		KMP算法的核心：就是避免不必要的回溯。
		那么什么是不必要的呢？
		问题由模式串决定，不是由目标决定！

		KMP算法是一个非常优秀的模式匹配算法。
		但是相较于其他模式匹配算法，该算法晦涩难懂！
		第一次接触该算法的鱼油往往会看得一头雾水，主要原因是：
			KMP算法在构造跳转表next过程中进行了多个层面的优化和抽象，使得KMP算法进行模式匹配的原理显得不那么直白。

		KMP算法的核心问题：
			如何以较小的代价计算KMP算法中所用到的跳转表next。

		KMP算法的Next数组实现原理：
			KMP的next数组求法是很不容易搞清楚的一部分，也是最重要的一部分。
			KMP的next数组简单来说：
				假设有两个字符串，一个是待匹配的字符串strText,一个是要查找的关键字strKey。
				现在我们要在strText中去查找是否包含strKey，用i来表示strText遍历到了哪个字符，用j来表示strKey匹配到了哪个字符。

			如果是暴力的查找方法，当strText[i ]和strKey[j]匹配失败的时候，i和j都要回退，然后从i-j的下一个字符开始重新匹配。
			而KMP就是保证i永远不回退，只回退j来使得匹配效率有所提升。

			它用的方法就是利用：
				strKey在失配的j为之前的成功匹配的子串的特征来寻找j应该回退的位置。
				而这个子串的特征就是前后缀的相同程度。
				所以next数组其实就是查找strKey中每一位前面的子串的前后缀有多少位匹配，从而决定j失配时应该回退到哪个位置。


		

*/