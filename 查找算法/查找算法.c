/*
查找算法：
	静态查找和动态查找
		静态查找：
        数据集合稳定，不需要添加，删除元素的查找操作。
		动态查找：
				数据集合在查找的过程中需要同时添加或删除元素的查找操作。

	查找结构：
		对于静态查找来说：
			我们不妨可以用线性表结构组织数据，这样可以使用顺序查找算法。
			如果我们再对关键字进行排序，则可以使用折半查找算法或斐波那契查找算法等来提高查找的效率。

		对于动态查找来说：
			我们则可以考虑使用二叉排序树的查找技术，另外我们还可以使用散列表结构来解决一些查找问题。
			这些技术我们都将在这部分教程里边介绍给大家。

	顺序查找：
		顺序查找又叫线性查找，是最基本的查找技术，它的查找过程是：
        从第一个（或者最后一个）记录开始，逐个进行记录的关键字和给定值进行比较，若某个记录的关键字和给定值相等，则查找成功。
        如果查找了所有的记录仍然找不到与给定值相等的关键字，则查找不成功。

	课后作业：
		假设以下有一个结构体存放的是学生的记录，每条记录包括：
        学号、姓名、成绩。
		请编写一个程序，要求输出0002编号，康小泡大姐大的具体信息。

插值查找（按比例查找）：
	折半查找又称为二分查找，是一种效率较高的查找算法。

	插值查找是二分查找演化而来。
	相比于二分查找(折半),该算法考虑的是每次折的时候折多少,即不一定是1/2;

	如在一本字典中找"fishc"这个单词。
	我们自己来操作肯定是先翻到字典开始的那一小部分,而不是从字典的中间开始进行折半查找。
	在二分查找中mid=(low+high)/2=low+1/2*(high-low)。
	插值查找就是对1/2，其实就是计算线性比例。
	(系数,或者说比例)进行改变，它将1/2变成 (key - array[low])/(array[high] - array[low])

	因为插值查找是依赖线性比例的，如果当前数组分布不是均匀的，那么该算法就不合适。

斐波那契查找（黄金分割法查找）：
	黄金比例
		黄金比例，又称黄金分割，是一个数学常数，一般以希腊字母  表示。
		可以透过以下代数式定义：
		黄金比例的准确值为：  ，是无理数，而大约值则为：
		应用时一般取1.618，就像圆周率在应用时取3.14一样。
		黄金分割具有严格的比例性、艺术性、和谐性，蕴藏着丰富的美学价值，而且呈现于不少动物和植物的外观。

	斐波那契查找
		斐波那契数列（前两项之和等于第三项，从1，1开始。F[k]）：
			1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89……

		前后两个数字的比值随着数列的增加，越来越接近黄金比值0.618。
		比如这里的89，把它想象成整个有序表的元素个数，而89是由前面的两个斐波那契数34和55相加之后的和。

		也就是说：
				把元素个数为89的有序表分成由前55个数据元素组成的前半段和由后34个数据元素组成的后半段。
				那么前半段元素个数和整个有序表长度的比值就接近黄金比值0.618。

		假如要查找的元素在前半段，那么继续按照斐波那契数列来看：
		55 = 34 + 21

		所以继续把前半段分成前34个数据元素的前半段和后21个元素的后半段。
		继续查找，如此反复，直到查找成功或失败，这样就把斐波那契数列应用到查找算法中了。

		从图中可以看出，当有序表的元素个数不是斐波那契数列中的某个数字时，需要把有序表的元素个数长度补齐。
		让它成为斐波那契数列中的一个数值，当然把原有序表截断肯定是不可能的，不然还怎么查找。
		然后图中标识每次取斐波那契数列中的某个值时(F[k])，都会进行-1操作。
		这是因为有序表数组位序从0开始的，纯粹是为了迎合位序从0开始。

线性索引查找：
	稠密索引
		如果记录是排好序的，我们就可以在记录上建立稠密索引。

		它是这样一系列存储块：
			块中只存放记录的键以及指向记录本身的指针，指针就是一个指向记录或存储块地址。
			稠密索引文件中的索引块保持键的顺序与文件中的排序顺序一致。
			既然我们假定查找键和指针所占存储空间远小于记录本身，我们就可以认为存储索引文件比存储数据文件所需存储块要少得多。
			当内存容纳不下数据文件，但能容纳下索引文件时，索引的优势尤为明显。
			这时，通过使用索引文件，我们每次查询只用一次I/O操作就能找到给定键值的记录。

	分块索引
		分块查找：
        分块查找又称索引顺序查找，它是顺序查找的一种改进方法。

		方法描述：
			将n个数据元素“按块有序”划分为m块（m<=n）。每一块中的数据元素不必有序，但块与块之间必须“按块有序”，
			即第1快中的任一元素的关键字都必须小于第2块中任一元素的关键字；
			而第2块中任一元素又都小于第3块中的任一元素，……

		操作步骤：
			1、先选取各快中的最大关键字构成一个索引表
			2、查找分两部分：
				先对索引表进行二分查找或顺序查找，以确定待查记录在哪一块中；
				然后在已确定的快中用顺序法进行查找。

		分块查找平均查找长度：
			设长度为n的表均匀地分成b块，每块含有s个记录，则：
			b=n/s

			顺序查找所在块，分块查找的平均查找长度为：
			(b+1)/2 + (s+1)/2 = (n/s+s)/2+1

			折半查找所在块，分块查找的平均查找长度为：
			log2(n/s+1)+s/2

	倒排索引
		倒排索引是一种索引方法，被用来存储在全文搜索下某个单词在一个文档或者一组文档中的存储位置的映射。

		它是文档检索系统中最常用的数据结构。

		有两种不同的反向索引形式：
				一条记录的水平反向索引（或者反向档案索引）包含每个引用单词的文档的列表。
				一个单词的水平反向索引（或者完全反向索引）又包含每个单词在一个文档中的位置。

		后者的形式提供了更多的兼容性（比如短语搜索），但是需要更多的时间和空间来创建。
		现在有两个数组：A和B
		A：
		I love FishC.com
		B：
		I am learning in FishC.com

二叉排序树：
	二叉排序树又称“二叉查找树”、“二叉搜索树”。
	
	在有序序列上，查找效率与二分查找等量级；但插入与删除效率高

	二叉排序树具有下列性质：
	1. 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；
	2. 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；
	3. 它的左、右子树也分别为二叉排序树。

	二叉排序树通常采用二叉链表作为存储结构。

	中序遍历二叉排序树可得到一个依据关键字的有序序列，一个无序序列可以通过构造一棵二叉排序树变成一个有序序列。
	构造树的过程即是对无序序列进行排序的过程。
	每次插入的新的结点都是二叉排序树上新的叶子结点。
	在进行插入操作时，不必移动其它结点，只需改动某个结点的指针，由空变为非空即可。

	二叉排序树的查找、插入与删除
		要在二叉树中找出查找最大最小元素是极简单的事情。
		从根节点一直往左走，直到无路可走就可得到最小值；
		从根节点一直往右走，直到无路可走，就可以得到最大值。

平衡二叉树：
	二叉查找树不是严格的O(logN)，导致了在真实场景中没有用武之地，谁也不愿意有O(N)的情况发生，
	当有很多数据灌到我的树中时，肯定会希望最好是以“完全二叉树”的形式展现。
	这样我才能做到“查找”是严格的O(logN)，比如把这种”树“调正到如下结构：

	里就涉及到了“树节点”的旋转，涉及到本讲重点。
	定义：
	父节点的左子树和右子树的高度之差不能大于1，也就是说不能高过1层，否则该树就失衡了，此时就要旋转节点，在
	编码时，我们可以记录当前节点的高度，比如空节点是-1，叶子节点是0，非叶子节点的height往根节点递增

	四种旋转情况
		① 左左情况（左子树的左边节点）：
			我们看到，在向树中追加“节点1”的时候，根据定义我们知道这样会导致了“节点3"失衡。
			满足“左左情况“，可以这样想，把这棵树比作齿轮，我们在“节点5”处把齿轮往下拉一个位置。
			也就变成了后面这样“平衡”的形式，如果用动画解释就最好理解了。

		② 右右情况（右子树的右边节点）：
			同样，”节点5“满足”右右情况“，其实我们也看到，这两种情况是一种镜像。
			当然操作方式也大同小异，我们在”节点1“的地方将树往下拉一位，最后也就形成了我们希望的平衡效果。

		③左右情况（左子树的右边节点）：
			从图中我们可以看到，当我们插入”节点3“时，“节点5”处失衡。
			注意，找到”失衡点“是非常重要的。
			当面对”左右情况“时，我们将失衡点的左子树进行"右右情况旋转"。
			然后进行”左左情况旋转“，经过这样两次的旋转就OK了。

		④右左情况(右子树的左边节点）：
			这种情况和“情景3”也是一种镜像关系，很简单。
			我们找到了”节点15“是失衡点，然后我们将”节点15“的右子树进行”左左情况旋转“，
			然后进行”右右情况旋转“，最终得到了我们满意的平衡。

	平衡二叉树的实现原理
		核心：
        平衡二叉树构建的基本思想就是在构建二叉排序树的过程中，每当插入一个结点。
		就立刻先检查是否因插入这个结点而导致树的平衡性遭到破坏，如果是，立刻找出最小不平衡子树。
		然后通过一定的规律进行调整，使之成为新的平衡子树。

		调整是什么呢？
		就是：旋转

		选取以下10个数据构造平衡二叉树：
		2，1，0，3，4，5，6，9，8，7

		下面的内容中：
			L代表左节点，R代表右节点。

		1、首先数据为2的结点作为根结点插入，接着插入1，仍是平衡的。
		再插入0是，2的平衡因子变为2，此时出现了不平衡，因此需要进行调整。
		最低不平衡结点为2，属于LL型，根据上述网址的内容，则调整过程如下：

		2、接着插入3，是平衡的，再插入4，此时出现了不平衡。
		结点 1 和2 的平衡因子都为 -2，结点2为最低不平衡结点，属于RR型，调整过程如下所示：

		3、接着插入5，此时结点 1 的平衡因子为 -2，导致不平衡。
		结点1为最低不平衡结点，属于RR型，调整如下：

		4、接着插入6，此时结点4的平衡因子为 -2，导致不平衡。
		结点4为最低不平衡结点，属于RR型，调整如下：

		5、接着插入9，是平衡的，再插入8，此时结点 3、5、6 的平衡因子都为 -2，导致不平衡。
		结点6为最低不平衡结点，属于RL型，调整如下：

		6、插入7，此时结点3、5的平衡因子为 -2，导致不平衡。
		最低不平衡结点为5，属于RL型，调整如下：
		
红黑树(red-black-tree, BST)：
	最常用的平衡二叉查找树
	插入/删除/查找的时间复杂度均为logn

	不要求左右高度差小于等于1，平衡性不如AVL
	每个节点多了一个bit，存储其是Red或Black
	
	如果插入与删除操作频繁，应该首选BST，而不是AVL
	
	根属性：根节点必须是黑色的
	红黑树中叶子节点为不存储数据的黑色空节点（表达中为了简便，可以省略黑色空节点）
	红属性：红节点的子节点必须是黑色的（任何相邻的两个节点（父子关系）不能同时为红色）
	黑属性：对于每个节点，从该节点到所有的叶子节点，每条路径上包含相同数目的黑节点
	
	红黑树的高度最多是2log(n+1)
		将红黑树中的红色节点删除，将黑色节点依次连接其父节点，那么得到一个完全四叉树
		一个完全二叉树的高度最多是logn, 那么一个完全四叉树的高度不超过log(n+1)
		恢复成红黑树，在红黑树中，每出现一个红色节点，就至少有一个黑色节点与之对应
		即使每个黑色节点对应一个红色节点，那么高度也不会超过2log(n+1)
		
	black height:the number of black nodes on any simple path from a node x(not including it)to a leaf
	
	红黑树的插入操作：
		如果树是空的，那么插入该节点作为根节点，将该节点的bit位置为black
		如果树非空，那么将该节点的bit位置为red
		如果一个新节点的父节点是red,那么检查父节点的兄弟节点sibling的颜色
			如果sibing是red, 那么将父节点与sibling的颜色反转（变为黑色）;然后检查新节点的父节点的父节点pp，如果pp是根节点，不需要recolor,如果不是根节点，那么将pp的颜色反转
			如果sibing是balck或null,那么先左旋再右旋，并且recolor。



多路查找树2-3树

多路查找树2-3树插入原理
	
多路查找树2-3树删除原理

多路查找树2-3-4树和B树
	B树：
	一个m阶的B树具有如下属性：
		如果根结点不是叶结点，则其至少有两棵子树
		每一个非根的分支结点都有k-1个元素（关键字）和k个孩子，其中k满足：⌈m/2⌉ <= k <= m
		所有叶子结点都位于同一层次

		每一个分支结点包含下列信息数据：
		n, A₀, K₁, A₁, K₂, A₂, K₃, A₃……
		其中K为关键字，且Ki < Ki+1
		Ai为指向子树根结点的指针

		一个m阶的B树具有如下属性：
		如果根结点不是叶结点，则其至少有两棵子树
		每一个非根的分支结点都有k-1个元素（关键字）和k个孩子，其中k满足：⌈m/2⌉ <= k <= m
		所有叶子结点都位于同一层次

		每一个分支结点包含下列信息数据：
		n, A₀, K₁, A₁, K₂, A₂, K₃, A₃……
		其中K为关键字，且Ki < Ki+1
		Ai为指向子树根结点的指针

散列表（哈希表）查找：
	我们要在a[]中查找key关键字的记录：
		顺序表查找：挨个儿比较
		有序表查找：二分法查找
		散列表查找：？
		
		记录的存储位置 = f(关键字)
		散列技术是在记录的存储位置和它的关键字之间建立一个确定的对应关系f,使得每个关键字key对应一个存储位置f(key)
		把这种对应关系f成为散列函数，又称为哈希（Hash）函数。采用散列技术将记录存储在一块连续的存储空间中，这块连续存储空间成为哈希表（Hash table）或散列表。

	散列表的查找步骤
		当存储记录时，通过散列函数计算出记录的散列地址
		当查找记录时，我们通过同样的散列函数计算记录的散列地址，并按此散列地址访问该记录

散列函数构造方法：
	构造散列函数的两个基本原则
		计算简单
		分布均匀

	直接定址法
		例一：有一个从1到100岁的人口数字统计表，其中，年龄作为关键字，哈希函数取关键字自身
		例二：如果现在要统计的是1980年以后出生的人口数，那么我们对出生年份这个关键字可以变换为：用年份减去1980的值来作为地址。
			即：f(key) = key – 1980
			
		f(key) = a * key + b

	数字分析法：
		数字分析法通常适合处理关键字位数比较大的情况，例如我们现在要存储某家公司员工登记表，如果用手机号作为关键字，
		那么我们发现抽取后面的四位数字作为散列地址是不错的选择。

	平方取中法
		平方取中法是将关键字平方之后取中间若干位数字作为散列地址。
		1234^2 = 1522756，取227作为散列地址
		
		不知道数据的分布，且关键字位数不高

	折叠法
		折叠法是将关键字从左到右分割成位数相等的几部分，然后将这几部分叠加求和，并按散列表表长取后几位作为散列地址。

	除留余数法
		此方法为最常用的构造散列函数方法，对于散列表长为m的散列函数计算公式为：
			f(key) = key mod p(p<=m)

		事实上，这个方法不仅可以对关键字直接取模，也可以通过折叠、平方取中后再取模。
		例如下表，我们对有12个记录的关键字构造散列表时，就可以用f(key) = key mod 12的方法。

		p的选择是关键，如果对于这个表格的关键字，p还选择12的话，那得到的情况未免也太糟糕了：

		p的选择很重要，如果我们把p改为11，那结果就另当别论啦：

	随机数法
		选择一个随机数，取关键字的随机函数值为它的散列地址。
		即：f(key) = random(key)。
		这里的random是随机函数，当关键字的长度不等时，采用这个方法构造散列函数是比较合适的。

	视不同的情况采用不同的散列函数
		现实中，我们应该视不同的情况采用不同的散列函数，这里给大家一些参考方向：
			计算散列地址所需的时间
			关键字的长度
			散列表的大小
			关键字的分布情况
			记录查找的频率

处理散列冲突的方法
	开放定址法
		所谓的开放定址法就是一旦发生了冲突，就去寻找下一个空的散列地址，只要散列表足够大，空的散列地址总能找到，并将记录存入。
		它的公式是：
		fi(key) = (f(key)+di) MOD m (di=1,2,…,m-1)
		例：假设关键字集合为{12, 67, 56, 16, 25, 37, 22, 29, 15, 47, 48, 34},使用除留余数法(m=12)求散列表

		可以修改di的取值方式，例如使用平方运算来尽量解决堆积问题：
		fi(key) = (f(key)+di) MOD m (di=1²,-1²,2²,-2²…,q²,-q²,q<=m/2)

		还有一种方法是，在冲突时，对于位移量di采用随机函数计算得到，我们称之为随机探测法：
		fi(key) = (f(key)+di) MOD m (di是由一个随机函数获得的数列)

	再散列函数法（多个散列函数，一个不行，换另一个）
		fi(key) = RHi(key) (i=1,2,3,…k)

	链地址法（图的邻接表的结构）
		例：假设关键字集合为{12, 67, 56, 16, 25, 37, 22, 29, 15, 47, 48, 34},同样使用除留余数法求散列表。
		

	公共溢出区法（基本表+溢出表，将冲突的数据放入溢出表）
		例：假设关键字集合为{12, 67, 56, 16, 25, 37, 22, 29, 15, 47, 48, 34},同样使用除留余数法求散列表。

散列表查找的代码实现














*/