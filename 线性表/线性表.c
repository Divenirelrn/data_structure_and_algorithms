#include <stdio.h>

/*
线性表(List)：
	由0个或过个数据元素组成的有限序列

前驱
后继

抽象数据类型(ADT)：
	数据类型：一组性质相同的值的集合及定义在此集合上的一些操作的总称，如整型、浮点型、字符型
		原子类型
		结构类型

	对已有的数据类型进行抽象，就有了抽象数据类型
	一个数学模型及定义在该模型上的一组操作（取决于逻辑特性，与计算机内部的实现无关）

	抽象数据类型的标准格式：
		ADT 抽象数据类型名
		Data
			数据元素之间的逻辑关系的定义
		Operation
			操作
		endADT

线性表的抽象数据类型：
	ADT 线性表（List）
	Data
		线性表的数据对象集合为{a1, a2, ...,an}，每个元素的类型均为DataType。其中，除了第一个元素a1外，都只有一个直接前驱元素，
		除最后一个元素an外，都只有一个直接后继元素，元素之间的关系是一对一的关系
	Operation
		InitList(*L):初始化
		ListEmpty(L):判断是否为空
		ClearList(*L)
		GetElem(L, i, *e)
		LocateElem(L,e):查找失败返回0
		ListInsert(*L, i, e)
		ListDelete(*L,i,*e)
		ListLength(L)
	endADT

线性表的顺序存储结构：
	三个属性：
		起始位置
		最大存储容量（一般初始化不变，扩容）
		当前长度

	LOC(ai) = LOC(a1) + (i-1)*c #c为字节数
		随时可以计算出任意位置的地址（随机存储结构）

	优缺点：
		读、写数据，时间复杂度为o(1),插入删除操作o(n)
		比较适合元素个数比较稳定，不经常插入与删除，经常存取数据的情况

		优点：
			无须为表示表中的逻辑关系而额外增加存储空间
			可以快速存取表中任意位置的元素

		缺点：
			插入与删除需要移动大量元素
			当线性表长度变化较大时，难以确定存储空间的容量
			容易造成存储空间的“碎片”

线性表的链式存储结构：
	数据域、指针域
	存储映像，结点
	单链表
	头指针（头结点，哨兵结点）

	头结点与头指针的异同：
		头指针：链表指向第一个结点的指针，若链表有头指针，则是指向头节点的指针
				头指针具有标识作用，所以常用头指针冠以链表的名字
				无论链表是否为空，头指针均不为空
				头指针是链表的必要元素

		头结点：为了操作的统一和方便而设立的，放在第一个元素的结点之前，其数据域一般无意义（也可以用来存放链表的长度）
				有了头结点，对在第一元素结点前插入与删除结点，与其他结点的操作就统一了
				头结点非必要

	对于插入与删除频繁的操作，单链表的优势较明显

	单链表的整表创建：
		思路：
			声明一个结点p和计数器变量i;
			初始化一个空链表L;
			让L的头结点的指针指向NULL，即建立一个带头结点的单链表；
			循环实现后继结点的赋值和插入。

		头插法：
			从一个空表开始，生成新结点，读取数据到新结点的数据域中，然后将新结点插入到当前链表的表头上，直到结束。即：
				先让新节点的next指向头节点之后
				然后让表头的next指向新节点

		尾插法：
			将新节点插入到链表尾部

	单链表的整表删除：
		思路：
			声明结点p和q;
			将第一个结点赋值给p,下一结点赋值给q;
			循环执行释放p和将q赋值给p的操作。

	单链表结构与顺序存储结构的优缺点：
		存储分配方式：
			顺序表用一段连续的存储单元依次存储线性表的数据元素
			单链表采用链式存储结构，用一组任意的存储单元存放线性表的元素

		时间性能：
			查找：顺序表o(1),单链表o(n)
			插入与删除：顺序表o(n)，单链表o(1)

		空间性能：
			顺序表需要预分配存储空间，分大了容易浪费空间，分小了容易溢出（溢出攻击）
			单链表无须事先分配存储空间

静态链表：
	用数组描述的链表称为静态链表，这种描述方式成为游标实现法
	对数组的第一个与最后一个元素做特殊处理，他们的data不存放数据
	通常把未使用的数组元素成为备用链表

	静态链表的插入：
		如何用静态模拟动态链表结构的存储空间分配，也就是需要的时候申请，不需要的时候释放

	静态链表优缺点：
		优点：
			插入与删除操作时，只需要修改游标，不需要移动元素，从而改进了在顺序结构中的插入与删除操作需要移动大量元素的缺点

		缺点：
			没有解决连续存储分配（数组）带来的表长难以确定的问题
			失去了顺序存储结构随机存取的特性

腾讯面试题：
	快速找到未知长度单链表的中间结点（快慢指针）

循环链表：
	将单链表中尾结点的指针由空指针改为指向头结点，就使整个单链表形成一个环，这种头尾相接的单链表成为循环链表

	判断是否为空表：head->Next = head;




	

*/
#define MAXSIZE 20
typedef int ElemType;
typedef struct
{
	ElemType data[MAXSIZE];
	int length; //线性表当前长度
} SqList;

//单链表
typedef struct Node
{
	ElemType data;
	struct  Node* Next;
} Node;

typedef struct Node* LinkList;

//静态链表
#define MAXSIZE 1000
typedef struct
{
	ElemType data; //数据
	int cur; //游标
}Component, StaticLinkList[MAXSIZE];

//循环链表
typedef struct CLinkList
{
	int data;
	struct CLinkList *next;
}node;

int main()
{
	
	return 0;
}