/*
图：
图的定义：
	图（Graph）是由顶点的有穷非空集合和顶点之间边的集合组成。
	通常表示为：G(V,E)

	G表示一个图，V是图G中顶点的集合，E是图G中边的集合。

	对于图的定义，我们需要明确几个注意的地方：
        线性表中我们把数据元素叫元素，树中叫结点，在图中数据元素我们则称之为顶点(Vertex)。
        线性表可以没有数据元素，称为空表，树中可以没有结点，叫做空树，而图结构在咱国内大部分的教材中强调顶点集合V要有穷非空。
        线性表中，相邻的数据元素之间具有线性关系，树结构中，相邻两层的结点具有层次关系，而图结构中，
		任意两个顶点之间都可能有关系，顶点之间的逻辑关系用边来表示，边集可以是空的。

	图的各种奇葩定义：
		无向边：若顶点Vi到Vj之间的边没有方向，则称这条边为无向边(Edge)，用无序偶(Vi,Vj)来表示
			上图G1是一个无向图，G1={V1,E1}，其中：V1={A,B,C,D}，E1={(A,B),(B,C),(C,D),(D,A),(A,C)}
		有向边：若从顶点Vi到Vj的边有方向，则称这条边为有向边，也成为弧(Arc)，用有序偶<Vi,Vj>来表示，Vi称为弧尾，Vj称为弧头。
			上图G2是一个无向图，G2={V2,E2}，其中V2={A,B,C,D}，E2={<B,A>,<B,C>,<C,A>,<A,D>}
		简单图：在图结构中，若不存在顶点到其自身的边，且同一条边不重复出现，则称这样的图为简单图。
		无向完全图：在无向图中，如果任意两个顶点之间都存在边，则称该图为无向完全图。含有n个顶点的无向完全图有n*(n-1)/2条边。
		有向完全图：在有向图中，如果任意两个顶点之间都存在方向互为相反的两条弧，则称该图为有向完全图。含有n个顶点的有向完全图有n*(n-1)条边。
		稀疏图和稠密图：这里的稀疏和稠密是模糊的概念，都是相对而言的，通常认为边或弧数小于n*logn（n是顶点的个数）的图称为稀疏图，反之称为稠密图。
		有些图的边或弧带有与它相关的数字。这种与图的边或弧相关的数叫做权(Weight)，带权的图通常称为网(Network)。
		假设有两个图G1=(V1,E1)和G2=(V2,E2)。如果V2&#8838;V1，E2&#8838;E1，则称G2为G1的子图(Subgraph)

	图的顶点与边之间的关系
		对于无向图G=(V,E)，如果边(V1,V2)∈E，则称顶点V1和V2互为邻接点(Adjacent)，即V1和V2相邻接。
		边(V1,V2)依附(incident)于顶点V1和V2，或者说边(V1,V2)与顶点V1和V2相关联。
		顶点V的度(Degree)是和V相关联的边的数目，记为TD(V)。
		如下图，顶点A与B互为邻接点，边(A,B)依附于顶点A与B上，顶点A的度为3。

		对于有向图G=(V,E)，如果有<V1,V2>∈E，则称顶点V1邻接到顶点V2，顶点V2邻接自顶点V1。
		以顶点V为头的弧的数目称为V的入度(InDegree)，记为ID(V)。
		以V为尾的弧的数目称为V的出度(OutDegree)，记为OD(V)，因此顶点V的度为TD(V)=ID(V)+OD(V)。
		下图顶点A的入度是2，出度是1，所以顶点A的度是3。

		无向图G=(V,E)中从顶点V1到顶点V2的路径(Path)。
		下图用红线列举了从顶点B到顶点D的四种不同路径

		如果G是有向图，则路径也是有向的。
		下图用红线列举顶点B到顶点D的两种路径，而顶点A到顶点B就不存在路径啦：

		路径的长度是路径上的边或弧的数目。
			第一个顶点到最后一个顶点相同的路径称为回路或环(Cycle)。

		简单环：（简单回路）
			序列中顶点不重复出现的路径称为简单路径，除了第一个顶点和最后一个顶点之外，其余顶点不重复出现的回路。

	连通图：
		在无向图G中，如果从顶点V1到顶点V2有路径，则称V1和V2是连通的。
		如果对于图中任意两个顶点Vi和Vj都是连通的，则称G是连通图(ConnectedGraph)

		无向图中的极大连通子图称为连通分量。

		注意以下概念：
				首先要是子图，并且子图是要连通的；
				连通子图含有极大顶点数；
				具有极大顶点数的连通子图包含依附于这些顶点的所有边。

		在有向图G中，如果对于每一对Vi到Vj都存在路径，则称G是强连通图。
		有向图中的极大强连通子图称为有向图的强连通分量。
		下图左侧并不是强连通图，右侧是。
		并且右侧是左侧的极大强连通子图，也是左侧的强连通分量。

		最后我们再来看连通图的生成树定义。
		所谓的一个连通图的生成树是一个极小的连通子图，它含有图中全部的n个顶点，但只有足以构成一棵树的n-1条边。
		without any cycle
		connect all the vertices

		如果一个有向图恰有一个顶点入度为0，其余顶点的入度均为1，则是一棵有向树。

图的存储结构：
		图的存储结构相比较线性表与树来说就复杂很多。

	我们回顾下：
			对于线性表来说，是一对一的关系，所以用数组或者链表均可简单存放。
			树结构是一对多的关系，所以我们要将数组和链表的特性结合在一起才能更好的存放。

	那么我们的图，是多对多的情况，另外图上的任何一个顶点都可以被看作是第一个顶点，任一顶点的邻接点之间也不存在次序关系。

	你发现了吗：它们其实都是一样的
	因为任意两个顶点之间都可能存在联系。
	因此无法以数据元素在内存中的物理位置来表示元素之间的关系。
	（内存物理位置是线性的，图的元素关系是平面的）

	如果用多重链表来描述倒是可以做到，但在几节课前的树章节我们已经讨论过。

	纯粹用多重链表导致的浪费是无法想像的。
		（如果各个顶点的度数相差太大，就会造成巨大的浪费）

	邻接矩阵（无向图）:
		考虑到图是由顶点和边或弧两部分组成，合在一起比较困难。
		那就很自然地考虑到分为两个结构来分别存储。
		顶点因为不区分大小、主次。
		所以用一个一维数组来存储是狠不错的选择。
		而边或弧由于是顶点与顶点之间的关系，一维数组肯定就搞不定了。
		那我们不妨考虑用一个二维数组来存储。
		于是我们的邻接矩阵方案就诞生了！
		图的邻接矩阵(Adjacency Matrix)存储方式是用两个数组来表示图。
		一个一维数组存储图中顶点信息，一个二维数组(称为邻接矩阵)存储图中的边或弧的信息。

		我们可以设置两个数组，顶点数组为vertex[4]={V0,V1,V2,V3}。
		边数组arc[4][4]为对称矩阵(0表示不存在顶点间的边，1表示顶点间存在边)。
		对称矩阵：
				所谓对称矩阵就是n阶矩阵的元满足
				a[i][j]=a[j][i](0<=i,j<=n)

		即从矩阵的左上角到右下角的主对角线为轴，右上角的元与左下角相对应的元全都是相等的。
		有了这个二维数组组成的对称矩阵，我们就可以很容易地知道图中的信息：
				要判定任意两顶点是否有边无边就非常容易了；
				要知道某个顶点的度，其实就是这个顶点Vi在邻接矩阵中第i行(或第i列)的元素之和；
				求顶点Vi的所有邻接点就是将矩阵中第i行元素扫描一遍，arc[ i ][ j ]为1就是邻接点咯。

	邻接矩阵（有向图）
		无向图的边构成了一个对称矩阵，貌似浪费了一半的空间。
		那如果是有向图来存放，会不会把资源都利用得很好呢？

		可见顶点数组vertex[4]={V0,V1,V2,V3}，弧数组arc[4][4]也是一个矩阵。
		但因为是有向图，所以这个矩阵并不对称。
		例如由V1到V0有弧，得到arc[1][0]=1，而V0到V1没有弧，因此arc[0][1]=0。
		另外有向图是有讲究的，要考虑入度和出度，顶点V1的入度为1。
		正好是第V1列的各数之和，顶点V1的出度为2，正好是第V1行的各数之和。
		在图的术语中，我们提到了网这个概念，事实上也就是每条边上带有权的图就叫网。

	邻接表：
		邻接表（无向图）
			邻接矩阵看上去是个不错的选择：
			第一是容易理解;
			第二是索引和编排都很舒服;
			但是我们也发现，对于边数相对顶点较少的图，这种结构无疑是存在对存储空间的极大浪费。

			因此我们可以考虑另外一种存储结构方式，例如把数组与链表结合一起来存储。
			这种方式在图结构也适用，我们称为邻接表(AdjacencyList)。
			邻接表的处理方法是这样：
					图中顶点用一个一维数组存储，当然，顶点也可以用单链表来存储，不过数组可以较容易地读取顶点信息，更加方便。
					图中每个顶点Vi的所有邻接点构成一个线性表，由于邻接点的个数不确定，所以我们选择用单链表来存储。

		邻接表（有向图）
			若是有向图，邻接表结构也是类似的。
			我们先来看下把顶点当弧尾建立的邻接表，这样很容易就可以得到每个顶点的出度：
			但也有时为了便于确定顶点的入度或以顶点为弧头的弧，我们可以建立一个有向图的逆邻接表：
			此时我们很容易就可以算出某个顶点的入度或出度是多少。
			判断两顶点是否存在弧也很容易实现。

		邻接表（网）
			对于带权值的网图，可以在边表结点定义中再增加一个数据域来存储权值即可：
			
		逆邻接表

	十字链表：
		邻接表固然优秀，但也有不足，例如对有向图的处理上，有时候需要再建立一个逆邻接表~
		那我们思考了：
			有没有可能把邻接表和逆邻接表结合起来呢？
		答案是肯定的，这就是我们现在要谈的十字链表(Orthogonal List)
		为此我们重新定义顶点表结点结构：

		十字链表的好处就是因为把邻接表和逆邻接表整合在了一起，这样既容易找到以Vi为尾的弧。
		也容易找到以Vi为头的弧，因而容易求得顶点的出度和入度。
		十字链表除了结构复杂一点外，其实创建图算法的时间复杂度是和邻接表相同的。
		因此，在有向图的应用中，十字链表也是非常好的数据结构模型。

	邻接多重表：
		讲了有向图的优化存储结构，对于无向图的邻接表，有没有问题呢？
		如果我们在无向图的应用中，关注的重点是顶点的话，那么邻接表是不错的选择。
		但如果我们更关注的是边的操作，比如对已经访问过的边做标记，或者删除某一条边等操作。
		邻接表就显得不那么方便了。

		若要删除(V0,V2)这条边，就需要对邻接表结构中边表的两个结点进行删除操作。

		因此，我们也仿照十字链表的方式，对边表结构进行改装，重新定义的边表结构如下：
		其中iVex和jVex是与某条边依附的两个顶点在顶点表中的下标。
		iLink指向依附顶点iVex的下一条边，jLink指向依附顶点jVex的下一条边。
		也就是说：在邻接多重表里边，边表存放的是一条边，而不是一个顶点。

	边集数组：
		边集数组是由两个一维数组构成，一个是存储顶点的信息，另一个是存储边的信息。
		这个边数组每个数据元素由一条边的起点下标(begin)、终点下标(end)和权(weight)组成。

图的遍历：
	树的遍历我们谈了四种方式，大家回忆一下。
	树因为根结点只有一个，并且所有的结点都只有一个双亲，所以不是很难理解。
	但是谈到图的遍历，那就复杂多了，因为：
			它的任一顶点都可以和其余的所有顶点相邻接，因此极有可能存在重复走过某个顶点或漏了某个顶点的遍历过程。
	对于图的遍历，如果要避免以上情况，那就需要科学地设计遍历方案。
	通常有两种遍历次序方案：
			它们是深度优先遍历和广度优先遍历。

	深度优先遍历：
		深度优先遍历(DepthFirstSearch)，也有称为深度优先搜索，简称为DFS。
		它的具体思想类似于课程开头讲的找钥匙方案，无论从哪一间房间开始都可以。
		将房间内的墙角、床头柜、床上、床下、衣柜、电视柜等挨个寻找，做到不放过任何一个死角。
		当所有的抽屉、储藏柜中全部都找遍，接着再寻找下一个房间。

		我们可以约定右手原则：
			在没有碰到重复顶点的情况下，分叉路口始终是向右手边走，每路过一个顶点就做一个记号。

		马踏棋盘算法（骑士周游问题）
			题目要求：
				国际象棋的棋盘为8*8的方格棋盘，现将“马”放在任意指定的方格中，按照“马”走棋的规则将“马”进行移动。
				要求每个方格只能进入一次，最终使得“马”走遍棋盘64个方格。

			一些相关的知识点:
				回溯法：
					之前我们谈过回溯法，还是那句话，指导思想很简单，就是一条路走到黑，碰壁了再回来一条路走到黑......
					一般和递归可以很好的搭配使用，还有深度优先搜索（DFS）。

				哈密尔顿路径：
					图G中的哈密尔顿路径指的是经过图G中每个顶点，且只经过一次的一条轨迹。如果这条轨迹是一条闭合的路径
					（从起点出发不重复地遍历所有点后仍能回到起始点），那么这条路径称为哈密尔顿回路

	广度优先遍历：
		广度优先遍历（BreadthFirstSearch），又称为广度优先搜索，简称BFS。
		如果以之前我们找钥匙的例子来讲：
				运用深度优先遍历意味着要先彻底查找完一个房间再开始另一个房间的搜索。

		但我们知道，钥匙放在沙发地下等犄角旮旯的可能性极低，因此我们运用新的方案：
			先看看钥匙是否放在各个房间的显眼位置，如果没有，再看看各个房间的抽屉有没有。

		这样逐步扩大查找的范围的方式我们称为广度优先遍历。
			那么要实现对图的广度遍历，我们可以利用队列来实现：

最小生成树（普里姆算法）：
	领导要求在A-I的9个网络中添加通信网络，连线之间的值叫做权值，表示村庄之间搭设通信网络的成本，领导要求用最小的成本完成任务。
	方案一：
		成本：11+26+20+22+18+21+24+19=161
	方案二：
		成本：8+12+10+11+17+19+16+7=100
	方案三：
		成本：8+12+10+11+16+19+16+7=99

	普里姆算法：
		普里姆算法（Prim算法）：
        图论中的一种算法，可在加权连通图里搜索最小生成树。意即由此算法搜索到的边子集所构成的树中，不但包括了连通图里的所有顶点
		（英语：Vertex (graph theory)），且其所有边的权值之和亦为最小。

最小生成树（克鲁斯卡尔算法）：
	无论是普里姆算法（Prim）还是克鲁斯卡尔算法（Kruskal），他们考虑问题的出发点都是：
        为使生成树上边的权值之和达到最小，则应使生成树中每一条边的权值尽可能的小。

	普里姆算法是以某顶点为起点，逐步找各个顶点上最小权值的边来构建最小生成树的。
	现在我们换一种思考方式：
		我们从边出发，因为权值是在边上嘛，直接去找最小权值的边来构建生成树是自然的想法，这也是克鲁斯卡尔算法的精髓。

	模拟计算机：
		步骤：
        1、新建图G，G中拥有原图中相同的节点，但没有边
        2、将原图中所有的边按权值从小到大排序
        3、从权值最小的边开始，如果这条边连接的两个节点于图G中不在同一个连通分量中，则添加这条边到图G中
        4、重复3，直至图G中所有的节点都在同一个连通分量中

最短路径（狄杰斯特拉算法）：
	在网图和非网图中，最短路径的含义是不同的。
	网图是：
			两顶点经过的边上权值之和最少的路径。
	非网图是：
			两顶点之间经过的边数最少的路径。

	我们把路径起始的第一个顶点称为源点，最后一个顶点称为终点。
	关于最短路径的算法，我们会介绍两种：
			迪杰斯特拉算法（Dijkstra）
			弗洛伊德算法（Floyd），下一讲介绍。

	迪杰斯特拉算法原理：
		简介：
        迪杰斯特拉算法（英语：Dijkstra's algorithm）是由荷兰计算机科学家艾兹赫尔・戴克斯特拉提出。
        迪杰斯特拉算法使用了广度优先搜索解决赋权有向图的单源最短路径问题，算法最终得到一个最短路径树。
        该算法常用于路由算法或者作为其他图算法的一个子模块。

		它并不是一下子就求出了V0到V8的最短路径，而是一步步求出它们之间顶点的最短路径。
		过程中都是：
				基于已经求出的最短路径的基础上，求得更远顶点的最短路径，最终得到你要的结果。

最短路径（弗洛伊德算法）：
	弗洛伊德算法复杂度比迪杰特斯拉算法要高，那我们为嘛还有讲它的必要呢？
	必须要讲阿，两个原因：
		1、迪杰特斯拉算法求的是一个顶点到所有顶点的最短路径，但弗洛伊德算法是求所有顶点到所有顶点的最短路径。
		2、弗洛伊德算法非常简洁优雅。

	Floyd-Warshall算法（英语：Floyd-Warshall algorithm），中文亦称弗洛伊德算法，是解决任意两点间的最短路径的一种算法。
		可以正确处理有向图或负权（但不可存在负权回路）的最短路径问题，同时也被用于计算有向图的传递闭包[2]。

	弗洛伊德算法原理：
		算法的原理是动态规划。
		设Di,j,k为从i到j的只以(1..k)集合中的节点为中间节点的最短路径的长度。
		若最短路径经过点k，则：
		Di,j,k = Di,k,k &#8722; 1 + Dk,j,k &#8722; 1
		若最短路径不经过点k，则：
		Di,j,k = Di,j,k &#8722; 1
		因此：
		Di,j,k = min(Di,k,k &#8722; 1 + Dk,j,k &#8722; 1,Di,j,k &#8722; 1)

拓扑排序：
	AOV网
		一个无环的有向图称为无环图（Directed Acyclic Graph），简称DAG图。
		所有的工程或者某种流程都可以分为若干个小的工程或者阶段，我们称这些小的工程或阶段为“活动”。
		在一个表示工程的有向图中，用顶点表示活动，用弧表示活动之间的优先关系。
		这样的有向图为顶点表示活动的网，我们称之为AOV网（Active On Vertex Network）。
		AOV网中的弧表示活动之间存在的某种制约关系。
		AOV网中不能存在回路，让某个活动的开始要以自己完成作为先决条件，显然是不可以的。

	拓扑排序
		设G= { V, E }是一个具有n个顶点的有向图。
		V中的顶点序列v1, v2, ...，vn，满足若从顶点vi到vj有一条路径。
		则在顶点序列中顶点vi必在vj之前，则我们称这样的顶点序列为一个拓扑排序。
		拓扑排序：
				所谓的拓扑排序，其实就是对一个有向图构造拓扑序列的过程。

	拓扑排序算法
		对AOV网进行拓扑排序的方法和步骤如下：
        从AOV网中选择一个没有前趋的顶点（该顶点的入度为0）并且输出它；
        从网中删去该顶点，并且删去从该顶点发出的全部有向边；
        重复上述两步，直到剩余网中不再存在没有前趋的顶点为止。

	算法时间复杂度：
		对一个具有n个顶点，e条边的网来说，初始建立入度为零的顶点栈，要检查所有顶点一次，执行时间为O(n)。
		排序中，若AOV网无回路，则每个顶点入、出栈各一次，每个表结点被检查一次，因而执行时间是 O(n+e)。
		所以，整个算法的时间复杂度是 O(n+e)。

关键路径：
	请问：
        汽车产造一辆汽车，最短需要多少时间呢
	按照现在的流水线水平：
			其中生产轮子：0.5天，发动机：3天，底盘：2天，外壳：2天，其他零部件：2天，全部零部件集中到一处：0.5天，组装成车并测试：2天
			最终：12天
	这种流水线式的分布处理思想，正是本次的重点。

	AOE网
		在一个表示工程的带权有向图中，用顶点表示事件，用有向边表示活动，用边上的权值表示活动的持续时间，这种有向图的边表示活动的网。
		我们把AOE网中没有入边的顶点称为始点或源点，没有出边的顶点称为终点或汇点。
			
	AOV网与AOE网的比较
		思考：
        关键路径如何建立在拓扑序列上

		参考：
			辨别关键活动就是要找e(i)=l(i)的活动。
			为了求得e(i)和l(i)，首先应求得事件的最早发生时间ve(j)和最迟发生时间vl(j)。如果活动ai由弧<j,k>表示，其持续时间记为dut(<j,k>)，则有如下关系
				e(i) = ve(j)
				l(i) = vl(k) - dut(<j,k>)

		求解ve(j)和vl(j)需分两个步进行：
		1） 从ve(0)=0开始向前推进求得ve(j)
		Ve(j) = Max{ve(i) + dut(<i,j>) };<i,j>属于T，j=1,2...,n-1
		其中T是所有以第j个顶点为头的弧的集合。

		2） 从vl(n-1) = ve(n-1)起向后推进求得vl(j)
		vl(i) = Min{vl(j) - dut(<i,j>};<i,j>属于S，i=n-2,...,0
		其中，S是所有以第i个顶点为尾的弧的集合。

		两个递推公式的计算必须分别在拓扑有序和逆拓扑有序的前提先进行。也就是说，ve(j-1)必须在vj的所有前驱的最早发生时间求得之后才能确定，
		而vl(j-1)必须在Vj的所有后继的最迟发生时间求得之后才能确定。因此可以在拓扑排序的基础上计算ve(j-1)和vl(j-1)。

	关键路径（代码讲解）：
		几个关键概念
			etv(Earliest Time Of Vertex)：
				事件最早发生时间，就是顶点的最早发生时间；
			ltv(Latest Time Of Vertex)：
				事件最晚发生时间，就是每个顶点对应的事件最晚需要开始的时间，如果超出此时间将会延误整个工期。
			ete(Earliest Time Of Edge)：
				活动的最早开工时间，就是弧的最早发生时间。
			lte(Latest Time Of Edge)：
				活动的最晚发生时间，就是不推迟工期的最晚开工时间。


				



	




*/