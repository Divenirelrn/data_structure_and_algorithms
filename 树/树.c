/*
树(Tree)是n(n >= 0)个结点的有限集。
当n=0时成为空树，在任意一棵非空树中：
    有且仅有一个特定的称为根(Root)的结点；
     当n>1时，其余结点可分为m(m>0)个互不相交的有限集T1、T2、...、Tm，其中每一个集合本身又是一棵树，并且称为根的子树(SubTree)。

结点分类:
    结点拥有的子树数称为结点的度-(Degree)，树的度取树内各结点的度的最大值。
    度为0的结点称为叶结点(Leaf)或终端结点；
    度不为0的结点称为分支结点或非终端结点，除根结点外，分支结点也称为内部结点。

结点间的关系:
    结点的子树的根称为结点的孩子(Child)。
    相应的，该结点称为孩子的双亲(Parent)，同一双亲的孩子之间互称为兄弟(Sibling)。
    结点的祖先是从根到该结点所经分支上的所有结点。

结点的层次:
    结点的层次(Level)从根开始定起，根为第一层，根的孩子为第二层。
    其双亲在同一层的结点互为堂兄弟。
    树中结点的最大层次称为树的深度(Depth)或高度

树的存储结构: 
    三种不同的表示法：
        双亲表示法、孩子表示法、孩子兄弟表示法。

    双亲表示法:
        双亲表示法，言外之意就是：
            以双亲作为索引的关键词的一种存储方式。
            我们假设以一组连续空间存储树的结点，同时在每个结点中，附设一个指示其双亲结点在数组中位置的元素。
            也就是说： 每个结点除了知道自己是谁之外，还知道它的粑粑妈妈在哪里。

        这样的存储结构，我们可以根据某结点的parent指针找到它的双亲结点。
        所用的时间复杂度是O(1)，索引到parent的值为-1时，表示找到了树结点的根
        可是，如果我们要知道某结点的孩子是什么？

        那么不好意思：请遍历整个树结构！

    孩子表示法:
        换个角度来考虑：
        由于树中每个结点可能有多棵子树，可以考虑用多重链表来实现。

        这里我们不限制大家的答案，给出三个参考的方案。
        先来看下方案一：
            根据树的度，声明足够空间存放子树指针的结点。

二叉树：
    二叉树（Binary Tree）是n（n>=0）个结点的有限集合，该集合或者为空集（空二叉树），
    或者由一个根结点和两棵互不相交的、分别称为根结点的左子树和右子树的二叉树组成。

二叉树的特点：
    每个结点最多有两棵子树，所以二叉树中不存在度大于2的结点。
    注意：
        不是都需要两棵子树，而是最多可以是两棵，没有子树或者有一棵子树也都是可以的。

    左子树和右子树是有顺序的，次序不能颠倒。

    即使树中某结点只有一棵子树，也要区分它是左子树还是右子树

五种基本形态：
    空二叉树
    只有一个根结点
    根结点只有左子树
    根结点只有右子树
    根结点既有左子树又有右子树

特殊二叉树
    斜树：斜树是一定要斜的，但斜也要斜得有范儿。
    满二叉树
        满二叉树的特点有：
            叶子只能出现在最下一层。
            非叶子结点的度一定是2。
            在同样深度的二叉树中，满二叉树的结点个数一定最多，同时叶子也是最多。
    完全二叉树
        对一棵具有n个结点的二叉树按层序编号，如果编号为i(1<=i<=n)的结点与同样深度的满二叉树中编号为i的结点位置完全相同
        完全二叉树的特点有：
            叶子结点只能出现在最下两层。
            最下层的叶子一定集中在左部连续位置。
            倒数第二层，若有叶子结点，一定都在右部连续位置。
            如果结点度为1，则该结点只有左孩子。
            同样结点树的二叉树，完全二叉树的深度最小。

二叉树的性质：
    性质一： 在二叉树的第i层上至多有2^(i-1)个结点(i>=1)
    性质二：深度为k的二叉树至多有2^k-1个结点(k>=1)
    性质三：对任何一棵二叉树T，如果其终端结点数为n0，度为2的结点数为n2，则n0=n2+1
        首先我们再假设度为1的结点数为n1，则二叉树T的结点总数n=n0+n1+n2
        其次我们发现连接数总是等于总结点数n-1，并且等于n1+2*n2
        所以n-1=n1+2*n2
        所以n0+n1+n2-1=n1+n2+n2
        最后n0=n2+1
    性质四：具有n个结点的完全二叉树的深度为[log2n]+1(取下限)
        那么对于倒数第二层的满二叉树我们同样很容易回推出它的结点数为n=2^(k-1)-1
        所以完全二叉树的结点数的取值范围是：2^(k-1)-1 < n <= 2^k-1
        由于n是整数，n <= 2^k-1可以看成n < 2^k
        同理2^(k-1)-1 < n可以看成2^(k-1) <= n
        所以2^(k-1) <= n < 2^k
        不等式两边同时取对数，得到k-1<=log&#8322;n<k
        由于k是深度，必须取整，所以k=&#8970;log&#8322;n&#8971;+1
    性质五：如果对一棵有n个结点的完全二叉树(其深度为&#8970;log&#8322;n&#8971;+1)的结点按层序编号，对任一结点i(1<=i<=n)有以下性质：
         如果i = 1，则结点 i 是二叉树的根，无双亲；如果i > 1，则其双亲是结点&#8970;i/2&#8971;
         如果2i > n，则结点 i 无做左孩子(结点 i 为叶子结点)；否则其左孩子是结点2i
         如果2i+1 > n，则结点 i 无右孩子；否则其右孩子是结点2i+1

 二叉树的存储结构：
    在前边的演示中，我们发觉很难单单只用顺序存储结构或者链式存储结构来存放。
    但是二叉树是一种特殊的树，由于它的特殊性，使得用顺序存储结构或链式存储结构都能够简单实现。
    二叉树的顺序存储结构就是：
        用一维数组存储二叉树中的各个结点，并且结点的存储位置能体现结点之间的逻辑关系。

    顺序存储结构
     
    二叉链表：
        既然顺序存储方式的适用性不强，那么我们就要考虑链式存储结构啦。
        二叉树的存储按照国际惯例来说一般也是采用链式存储结构的。
        二叉树每个结点最多有两个孩子，所以为它设计一个数据域和两个指针域是比较自然的想法。
        我们称这样的链表叫做二叉链表。

二叉树的遍历：
    二叉树的遍历(traversing binary tree)是指：
        从根结点出发，按照某种次序依次访问二叉树中所有结点，使得每个结点被访问一次且仅被访问一次。
    这里有两个关键词：
        次序和访问

    叉树的遍历次序不同于线性结构，线性结构最多也就是分为顺序、循环、双向等简单的遍历方式。
    树的结点之间不存在唯一的前驱和后继这样的关系，在访问一个结点后，下一个被访问的结点面临着不同的选择。

    遍历方法：
        前序遍历
        中序遍历
        后序遍历
        层序遍历

    前序遍历：
        若二叉树为空，则空操作返回，否则先访问根结点，然后前序遍历左子树，再前序遍历右子树。

    中序遍历：
        若树为空，则空操作返回，否则从根结点开始（注意并不是先访问根结点），中序遍历根结点的左子树，然后是访问根结点，最后中序遍历右子树。

    后序遍历：
        若树为空，则空操作返回，否则从左到右先叶子后结点的方式遍历访问左右子树，最后访问根结点。

    层序遍历：
        若树为空，则空操作返回，否则从树的第一层，也就是根结点开始访问，从上而下逐层遍历，在同一层中，按从左到右的顺序对结点逐个访问。

二叉树的建立和遍历算法

线索二叉树：
    为什么需要线索二叉树呢？
        单链表并不总能满足他们设计的程序某些要求的时候，发明了双向链表来弥补一样。
        线索二叉树也是在需求中被创造的！

    那普通的二叉树到底有什么缺陷让我们发指呢？
        一，浪费空间
        二，浪费时间

树、森林及二叉树的相互转换:
    你就会想：如果所有的树都像二叉树一样方便处理就好了。

    普通树转换为二叉树:
        步骤如下：
        加线，在所有兄弟结点之间加一条连线。
        去线，对树中每个结点，只保留它与第一孩子结点的连线，删除它与其他孩子结点之间的连线。
        层次调整，以树的根结点为轴心，将整棵树顺时针旋转一定的角度，使之结构层次分明。

    森林转换为二叉树:
        步骤如下：
        把每棵树转换为二叉树。
        第一棵二叉树不动，从第二棵二叉树开始，依次把后一棵二叉树的根结点作为前一棵二叉树的根结点的右孩子，用线连接起来。

    二叉树转换为树、森林:
        二叉树转换为普通树是刚才的逆过程，步骤也就是反过来做而已。
        判断一棵二叉树能够转换成一棵树还是森林。
        标准很简单，那就是只要看这棵二叉树的根结点有没有右孩子，有的话就是森林，没有的话就是一棵树。

    树与森林的遍历
        树的遍历分为两种方式：一种是先根遍历，另一种是后根遍历。
        先根遍历：先访问树的根结点，然后再依次先根遍历根的每棵子树。
        后根遍历：先依次遍历每棵子树，然后再访问根结点。

        森林的遍历也分为前序遍历和后序遍历，其实就是:
            按照树的先根遍历和后根遍历依次访问森林的每一棵树。

        我们的惊人发现：
            树、森林的前根（序）遍历和二叉树的前序遍历结果相同，树、森林的后根（序）遍历和二叉树的中序遍历结果相同！

赫夫曼树:
    在数据膨胀、信息爆炸的今天，数据压缩的意义不言而喻。
    谈到数据压缩，就不能不提赫夫曼（Huffman）编码，赫夫曼编码是首个实用的压缩编码方案。

    即使在今天的许多知名压缩算法里，依然可以见到赫夫曼编码的影子。
    另外，在数据通信中，用二进制给每个字符进行编码时不得不面对的一个问题：
        如何使电文总长最短且不产生二义性

    根据字符出现频率，利用赫夫曼编码可以构造出一种不等长的二进制。

    使编码后的电文长度最短，且保证不产生二义性。
    介绍赫夫曼编码前，我们必须得介绍赫夫曼树。
    什么叫做赫夫曼树呢？
    我们先来看一个例子。

    if( a < 60 )
        printf(“不及格”);
        else if( a < 70 )
        printf(“及格”);
        else if( a < 90 )
        printf(“良好”);
        else
        printf(“优秀”);

    定义与原理:
        我们先把这两棵二叉树简化成叶子结点带权的二叉树
        （注：树结点间的连线相关的数叫做权（Weight））。

        结点的路径长度：从根结点到该结点的路径上的连接数。
        树的路径长度：树中每个叶子结点的路径长度之和。
        结点带权路径长度：结点的路径长度与结点权值的乘积。
        树的带权路径长度：WPL(Weighted Path Length)是树中所有叶子结点的带权路径长度之和。
        WPL的值越小，说明构造出来的二叉树性能越优。

        那么现在的问题是：
        如何构造出最优的赫夫曼树呢？

    赫夫曼编码:
        上一节课我们已经谈了赫夫曼树的基本原理和构造方式。
        而赫夫曼编码可以很有效地压缩数据（通常可以节省20%~90%的空间，具体压缩率依赖于数据的特性）。

        名词解释:
            定长编码：像ASCII编码
            变长编码：单个编码的长度不一致，可以根据整体出现频率来调节
            前缀码：所谓的前缀码，就是没有任何码字是其他码字的前缀

        赫夫曼思路:
            五个代码基础模块：
                build a priority queue
                build a huffmanTree
                build a huffmanTable
                encode
                decode

            赫夫曼编码步骤：
                 一、对给定的n个权值{W1,W2,W3,...,Wi,...,Wn}构成n棵二叉树的初始集合F= {T1,T2,T3,...,Ti,...,Tn}，
                 其中每棵二叉树Ti中只有一个权值为Wi的根结点，它的左右子树均为空。（为方便在计算机上实现算 法，一般还要求以Ti的权值Wi的升序排列。）
                二、在F中选取两棵根结点权值最小的树作为新构造的二叉树的左右子树，新二叉树的根结点的权值为其左右子树的根结点的权值之和。
                三、从F中删除这两棵树，并把这棵新的二叉树同样以升序排列加入到集合F中。
                四、重复二和三两步，直到集合F中只有一棵二叉树为止。
                简易的理解就是，假如我有A,B,C,D,E五个字符，出现的频率（即权值）分别为5,4,3,2,1,
                那么我们第一步先取两个最小权值作为左右子树构造一个新树，即取1，2构成新树，其结点为1+2=3，如图：

                虚线为新生成的结点，第二步再把新生成的权值为3的结点放到剩下的集合中，所以集合变成{5,4,3,3}。
                再根据第二步，取最小的两个权值构成新树，如图：

                再依次建立哈夫曼树，如下图：

                其中各个权值替换对应的字符即为下图：

                所以各字符对应的编码为：
                    A->11,B->10,C->00,D->011,E->010

                霍夫曼编码是一种无前缀编码。解码时不会混淆。其主要应用在数据压缩，加密解密等场合。









*/

// 树的双亲表示法结点结构定义
#define MAX_TREE_SIZE 100

typedef int ElemType;

typedef struct PTNode
{
    ElemType data;        // 结点数据
    int parent;                // 双亲位置
}PTNode;

typedef struct
{
    PTNode nodes[MAX_TREE_SIZE];
    int r;                        // 根的位置
    int n;                        // 结点数目
}PTree;

/*树的孩子表示法结点结构定义*/
#define MAX_TREE_SIZE 100

typedef char ElemType;

// 孩子结点
typedef struct CTNode
{
    int child;                                // 孩子结点的下标
    struct CTNode* next;        // 指向下一个孩子结点的指针
} *ChildPtr;

// 表头结构
typedef struct
{
    ElemType data;                        // 存放在树中的结点的数据
    int parent;                                // 存放双亲的下标
    ChildPtr firstchild;        // 指向第一个孩子的指针
} CTBox;

// 树结构
typedef struct
{
    CTBox nodes[MAX_TREE_SIZE];        // 结点数组
    int r, n;
}

/*二叉链表*/
typedef struct BiTNode
{
    ElemType data;
    struct BiTNode* lchild, * rchild;
} BiTNode, * BiTree;
