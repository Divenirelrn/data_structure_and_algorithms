/*
递归：
	递归效率低（保存与恢复现场现场需要入栈与出栈， 需要保存寄存器的状态，浪费资源）
	斐波那契数列

	每个递归定义必须至少有一个条件，当满足这个条件时递归不再进行，即函数不再调用自身而是返回值。
	对比了两种实现斐波那契的代码（上一讲末尾），迭代和递归的区别是：
		迭代使用的是循环结构
		递归使用的是选择结构。
	使用递归能使程序的结构更清晰、更简洁、更容易让人理解，从而减少读懂代码的时间。
	但大量的递归调用会建立函数的副本，会消耗大量的时间和内存，而迭代则不需要此种付出。
	递归函数分为调用和回退阶段，递归的回退顺序是它调用顺序的逆序。
	举个例子，计算n的阶乘n!
	int  factorial( n )
	{
		if( 0 == n )    return 1;
		else   return  n * factorial( n - 1 );
	}

分治;
	而分治思想在算法设计中也是非常常见的。
	当一个问题规模较大且不易求解的时候，就可以考虑：将问题分成几个小的模块，逐一解决。
	分治思想和递归算是有亲兄弟的关系了，因为采用分治思想处理问题，其各个小模块通常具有与大问题相同的结构。
	这种特性也使递归技术有了用武之地。

	折半查找法：
		折半查找法是一种常用的查找方法，该方法通过：
        不断缩小一半查找的范围，直到达到目的，所以效率比较高。

		从算法的折半查找的过程我们不难看出，这实际上也是一个递归的过程：
        因为每次都将问题的规模减小至原来的一半，而缩小后的子问题和原问题类型保持一致。

	汉诺塔问题

	八皇后问题











*/